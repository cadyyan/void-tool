// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: players.sql

package sqlitedb

import (
	"context"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (
    id,
    username,
    created_on
) VALUES (
    ?,
    ?,
    ?
) RETURNING id, username, created_on
`

type CreatePlayerParams struct {
	ID        string
	Username  string
	CreatedOn string
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, createPlayer, arg.ID, arg.Username, arg.CreatedOn)
	var i Player
	err := row.Scan(&i.ID, &i.Username, &i.CreatedOn)
	return i, err
}

const createPlayerIfNotExist = `-- name: CreatePlayerIfNotExist :exec
INSERT OR IGNORE INTO players (
    id,
    username,
    created_on
) VALUES (
    ?,
    ?,
    ?
)
`

type CreatePlayerIfNotExistParams struct {
	ID        string
	Username  string
	CreatedOn string
}

func (q *Queries) CreatePlayerIfNotExist(ctx context.Context, arg CreatePlayerIfNotExistParams) error {
	_, err := q.db.ExecContext(ctx, createPlayerIfNotExist, arg.ID, arg.Username, arg.CreatedOn)
	return err
}

const getAllPlayerSkillsByPlayerName = `-- name: GetAllPlayerSkillsByPlayerName :many
WITH ordered_skill_entries AS (
    SELECT
        player_skills.player_id,
        player_skills.name,
        player_skills.day,
        player_skills.experience,
        player_skills.level,
        ROW_NUMBER() OVER (
            PARTITION BY player_skills.name
            ORDER BY player_skills.day DESC
        ) AS row_num
    FROM player_skills
    INNER JOIN players
        ON
            player_skills.player_id = players.id
            AND
            players.username = ?
)

SELECT
    ordered_skill_entries.player_id,
    ordered_skill_entries.name,
    ordered_skill_entries.day,
    ordered_skill_entries.experience,
    ordered_skill_entries.level
FROM ordered_skill_entries
WHERE
    ordered_skill_entries.row_num = 1
`

type GetAllPlayerSkillsByPlayerNameRow struct {
	PlayerID   string
	Name       string
	Day        string
	Experience float64
	Level      int64
}

func (q *Queries) GetAllPlayerSkillsByPlayerName(ctx context.Context, username string) ([]GetAllPlayerSkillsByPlayerNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayerSkillsByPlayerName, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPlayerSkillsByPlayerNameRow
	for rows.Next() {
		var i GetAllPlayerSkillsByPlayerNameRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.Day,
			&i.Experience,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPlayers = `-- name: GetAllPlayers :many
SELECT
    id,
    username,
    created_on
FROM players
`

func (q *Queries) GetAllPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(&i.ID, &i.Username, &i.CreatedOn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighscoresForSkill = `-- name: GetHighscoresForSkill :many
WITH latest_row AS (
    SELECT
        player_id,
        name,
        MAX(day) AS latest_day
    FROM player_skills
    GROUP BY player_id, name
),

latest_skills_by_player AS (
    SELECT
        player_skills.player_id,
        player_skills.name,
        player_skills.experience,
        player_skills.level
    FROM player_skills
    INNER JOIN latest_row
        ON
            player_skills.player_id = latest_row.player_id
            AND
            player_skills.name = latest_row.name
            AND
            player_skills.day = latest_row.latest_day
    WHERE
        player_skills.name = ?
)

SELECT
    players.id,
    players.username,
    skills.name,
    skills.experience,
    skills.level
FROM latest_skills_by_player AS skills
INNER JOIN players
    ON
        skills.player_id = players.id
ORDER BY skills.experience DESC
`

type GetHighscoresForSkillRow struct {
	ID         string
	Username   string
	Name       string
	Experience float64
	Level      int64
}

func (q *Queries) GetHighscoresForSkill(ctx context.Context, name string) ([]GetHighscoresForSkillRow, error) {
	rows, err := q.db.QueryContext(ctx, getHighscoresForSkill, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighscoresForSkillRow
	for rows.Next() {
		var i GetHighscoresForSkillRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Experience,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerByName = `-- name: GetPlayerByName :one
SELECT
    id,
    username,
    created_on
FROM players
WHERE
    username = ?
`

func (q *Queries) GetPlayerByName(ctx context.Context, username string) (Player, error) {
	row := q.db.QueryRowContext(ctx, getPlayerByName, username)
	var i Player
	err := row.Scan(&i.ID, &i.Username, &i.CreatedOn)
	return i, err
}

const getPlayerSkillOverTimeByPlayerName = `-- name: GetPlayerSkillOverTimeByPlayerName :many
SELECT
    player_skills.player_id,
    player_skills.name,
    player_skills.day,
    player_skills.experience,
    player_skills.level
FROM player_skills
INNER JOIN players
    ON
        player_skills.player_id = players.id
        AND
        players.username = ?
WHERE
    player_skills.name = ?
ORDER BY player_skills.day ASC
`

type GetPlayerSkillOverTimeByPlayerNameParams struct {
	Username string
	Name     string
}

type GetPlayerSkillOverTimeByPlayerNameRow struct {
	PlayerID   string
	Name       string
	Day        string
	Experience float64
	Level      int64
}

func (q *Queries) GetPlayerSkillOverTimeByPlayerName(ctx context.Context, arg GetPlayerSkillOverTimeByPlayerNameParams) ([]GetPlayerSkillOverTimeByPlayerNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerSkillOverTimeByPlayerName, arg.Username, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSkillOverTimeByPlayerNameRow
	for rows.Next() {
		var i GetPlayerSkillOverTimeByPlayerNameRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.Day,
			&i.Experience,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPlayerSkill = `-- name: RecordPlayerSkill :exec
INSERT INTO player_skills (
    player_id,
    name,
    day,
    experience,
    level
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
) ON CONFLICT (player_id, name, day)
DO UPDATE SET experience = excluded.experience, level = excluded.level
`

type RecordPlayerSkillParams struct {
	PlayerID   string
	Name       string
	Day        string
	Experience float64
	Level      int64
}

func (q *Queries) RecordPlayerSkill(ctx context.Context, arg RecordPlayerSkillParams) error {
	_, err := q.db.ExecContext(ctx, recordPlayerSkill,
		arg.PlayerID,
		arg.Name,
		arg.Day,
		arg.Experience,
		arg.Level,
	)
	return err
}
